# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/SathishMalaVish/BookScape-Explorer/blob/main/project.ipynb
"""

!pip install streamlit
!pip install mysql-connector-python
!pip install pyngrok
!npm install localtunnel
!pip install ngrok
!pip install mysql
!pip install requests pandas pymysql streamlit
!pip install streamlit-lottie

import requests
import pymysql
import pandas as pd
import streamlit as st
from mysql.connector import Error
import plotly.express as px
from google.colab import files
from requests.api import head
from mysql.connector import Error
from tabulate import tabulate
from pyngrok import ngrok
import streamlit_lottie as st_lottie
from PIL import Image


def set_light_background(color="#f9f9f9"):
  st.markdown(
      f"""
      <style>
      html, body, .stApp {{
          background-color: {color}; /* Full-screen background color */
          height: 100%; /* Cover the full height of the viewport */
          margin: 0; /* Remove any margin or spacing */
          padding: 0; /* Remove any padding */
          top: 0; /* Ensure no space at the top */
      }}
      </style>
      """,
      unsafe_allow_html=True
  )



def set_sidebar_color(bg_color="#90EE90", text_color="#000000"):
    st.markdown(
        f"""
        <style>
        [data-testid="stSidebar"] {{
            background-color: {bg_color};
            color: {text_color};
        }}
        [data-testid="stSidebar"] .css-1v3fvcr {{
            color: {text_color};
        }}
        </style>
        """,
        unsafe_allow_html=True
    )



api_key = "AIzaSyCZfDjVuOwsi7cM3rB1TVmFBqsasXCEW88"   # API key

# Google Books API Constants
API_URL = "https://www.googleapis.com/books/v1/volumes"
MAX_RESULTS = 40
TOTAL_BOOKS = 1500


# TiDB Connection
TIDB_HOST = 'gateway01.ap-southeast-1.prod.aws.tidbcloud.com'
TIDB_PORT = 4000
TIDB_USER = '3nitUUKsZ9vMwCU.root'
TIDB_PASSWORD = 'rXPvkXcel0MlnGKI'
TIDB_DB = 'class'

# Function to fetch books from Google Books API
def fetch_books_from_api(query):
    all_books = []
    start_index = 0

    while len(all_books) < TOTAL_BOOKS:
        params = {
            'q': query,
            'startIndex': start_index,
            'maxResults': MAX_RESULTS
        }
        response = requests.get(API_URL, params=params)
        data = response.json()

        if 'items' in data:
            all_books.extend(data['items'])
            start_index += MAX_RESULTS
        else:
            break

    return all_books[:TOTAL_BOOKS]

# Create the schema in TiDB
def create_db_schema():
    conn = pymysql.connect(
        host=TIDB_HOST,
        port=TIDB_PORT,
        user=TIDB_USER,
        password=TIDB_PASSWORD,
        db=TIDB_DB,
        ssl={'ssl_ca': '/content/cert/ca.pem'}
    )
    cursor = conn.cursor()

    cursor.execute("DROP TABLE IF EXISTS books;")

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS books (
        bookid INT PRIMARY KEY AUTO_INCREMENT,
        searchkey TEXT,
        booktitle TEXT,
        booksubtitle TEXT,
        bookauthors TEXT,
        bookdescription TEXT,
        publisher TEXT,
        industryIdentifiers TEXT,
        textreadingModes TEXT,
        imagereadingModes TEXT,
        pageCount INT,
        categories TEXT,
        language VARCHAR(255),
        imageLinks TEXT,
        ratingsCount INT,
        averageRating DECIMAL(3,2),
        country VARCHAR(50),
        saleability TEXT,
        isEbook BOOLEAN,
        amountlistPrice DECIMAL(10,2),
        currencyCode_listPrice VARCHAR(255),
        amountretailPrice DECIMAL(10,2),
        currencyCoderetailPrice VARCHAR(255),
        buyLink TEXT,
        year TEXT
    );
    """)
    conn.commit()
    cursor.close()
    conn.close()

# Store book data into TiDB
def store_books_in_tidb(books, query):
    conn = pymysql.connect(
        host=TIDB_HOST,
        port=TIDB_PORT,
        user=TIDB_USER,
        password=TIDB_PASSWORD,
        db=TIDB_DB,
        ssl={'ssl_ca': '/content/cert/ca.pem'}
    )
    cursor = conn.cursor()
    for item in books:
        volume_info = item.get('volumeInfo', {})
        sale_info = item.get('saleInfo', {})

        volume_info = item['volumeInfo']
        title = volume_info.get('title', 'N/A')
        subtitle = volume_info.get('subtitle', 'N/A')
        bookauthors = ', '.join(volume_info.get('authors', ['N/A']))
        description = volume_info.get('description', 'N/A')
        publisher = volume_info.get('publisher', 'N/A')
        industry_identifiers = ', '.join(str(x) for x in volume_info.get('industryIdentifiers', []))
        text_reading_modes = volume_info.get('readingModes', {}).get('text', 'N/A')
        image_reading_modes = volume_info.get('readingModes', {}).get('image', 'N/A')
        page_count = volume_info.get('pageCount', 0)
        categories = ', '.join(volume_info.get('categories', ['N/A']))
        language = volume_info.get('language', 'en')
        image_links = ', '.join(volume_info.get('imageLinks', {}).values())
        ratings_count = volume_info.get('ratingsCount', 0)
        average_rating = volume_info.get('averageRating', 0)
        country = sale_info.get('country', 'US')
        saleability = sale_info.get('saleability', False)
        is_ebook = sale_info.get('isEbook', False)
        list_price = sale_info.get('listPrice', {}).get('amount', 0)
        currency_code_list_price = sale_info.get('listPrice', {}).get('currencyCode', 'USD')
        retail_price = sale_info.get('retailPrice', {}).get('amount', 0)
        currency_code_retail_price = sale_info.get('retailPrice', {}).get('currencyCode', 'USD')
        buy_link = sale_info.get('buyLink', 'N/A')
        published_date = volume_info.get('publishedDate', '0000')
        try:
            year = int(''.join(filter(str.isdigit, published_date[:4])))
        except ValueError:
            year = 0

        cursor.execute("""
            INSERT INTO books (searchkey, booktitle, booksubtitle, bookauthors, bookdescription, publisher,
            industryIdentifiers, textreadingModes, imagereadingModes, pageCount, categories, language, imageLinks,
            ratingsCount, averageRating, country, saleability, isEbook, amountlistPrice, currencyCode_listPrice,
            amountretailPrice, currencyCoderetailPrice, buyLink, year)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (query, title, subtitle, bookauthors, description, publisher, industry_identifiers, text_reading_modes,
              image_reading_modes, page_count, categories, language, image_links, ratings_count, average_rating,
              country, saleability, is_ebook, list_price, currency_code_list_price, retail_price,
              currency_code_retail_price, buy_link, year))
    conn.commit()
    cursor.close()
    conn.close()

# Sidebar navigation
set_sidebar_color(bg_color="#10A8B8", text_color="#FFFFFF")
st.sidebar.markdown(f'<iframe src="https://lottie.host/embed/1f19890d-b328-454b-85a5-03f96558e8c2/1qLR18ZEmb.lottie" width="100" height="100" style="border:none;"></iframe>', unsafe_allow_html=True)
st.sidebar.title("üìö Book Finder")
menu = st.sidebar.radio("**Select an option**",["**üè† Home**","**üìñ Book Scraping Application**", "**üìä Data Analysis**"])
if menu == "**üè† Home**":
    # Use st.markdown to embed the Lottie animation as an iframe
    set_sidebar_color(bg_color="#10A8B8", text_color="#FFFFFF")
    st.markdown(f'<iframe src="https://lottie.host/embed/bf675c7b-d0fa-4c12-bbb4-cee38168cb31/BoaIdyWKZu.lottie" width="200" height="200" style="border:none;"></iframe>', unsafe_allow_html=True)
    st.title("Welcome to the Book Explorer App")
    st.write("""
        Discover books, analyze data, and explore insights.
        Use the menu to navigate through features.
    """)

elif menu == "**üìñ Book Scraping Application**":
  #set_light_background("#ADD8E6")  #light blue
  set_sidebar_color(bg_color="#10A8B8", text_color="#FFFFFF")

# Streamlit App
  st.title('Book Scraping Application :book: ')
  keyword = st.text_input("**Enter a keyword:**")
  if st.button("üîç Search"):
      if keyword:
          with st.spinner("Fetching data..."):
              books = fetch_books_from_api(keyword)
          if books:
            with st.spinner("Fetching data may take a few seconds; please wait."):
              create_db_schema()
              store_books_in_tidb(books, keyword)
              st.success("üòäThank you for your patience!")
              st.success(f"‚úÖ Found {len(books)} books for keyword: {keyword}")
              st.markdown(f'<iframe src="https://lottie.host/embed/bf675c7b-d0fa-4c12-bbb4-cee38168cb31/BoaIdyWKZu.lottie" width="200" height="200" style="border:none;"></iframe>', unsafe_allow_html=True)

          else:
              st.error("No data found for the given query.")
      else:
          st.error("Please enter a search term.")


elif menu == "**üìä Data Analysis**":


  # TiDB Connection
  TIDB_HOST = 'gateway01.ap-southeast-1.prod.aws.tidbcloud.com'
  TIDB_PORT = 4000
  TIDB_USER = '3nitUUKsZ9vMwCU.root'
  TIDB_PASSWORD = 'rXPvkXcel0MlnGKI'
  TIDB_DB = 'class'

  # SQL Queries
  queries = {
      "1. Check Availability of eBooks vs Physical Books":
          "SELECT CASE WHEN isEbook = 1 THEN 'eBooks' ELSE 'Physical Books' END AS Book_Type, COUNT(*) AS book_count FROM books GROUP BY isEbook;",
      "2. Find the Publisher with the Most Books Published":
          "SELECT publisher, COUNT(*) AS book_count FROM books WHERE publisher != 'N/A' GROUP BY publisher ORDER BY book_count DESC LIMIT 1;",
      "3. Identify the Publisher with the Highest Average Rating":
          "SELECT publisher, AVG(averageRating) AS avg_rating FROM books GROUP BY publisher ORDER BY avg_rating DESC LIMIT 1;",
      "4. Get the Top 5 Most Expensive Books by Retail Price":
          "SELECT booktitle, amountretailPrice, imageLinks FROM books ORDER BY amountretailPrice DESC LIMIT 5;",
      "5. Find Books Published After 2010 with at Least 500 Pages":
          "SELECT booktitle, imageLinks, pageCount, year FROM books WHERE year > 2010 AND pageCount >= 500;",
      "6. List Books with Discounts Greater than 20%":
          """SELECT imageLinks, booktitle, (amountlistPrice - amountretailPrice) / amountlistPrice AS discount_percentage
            FROM books WHERE
            (amountlistPrice - amountretailPrice) / amountlistPrice > 0.02;""",
      "7. Find the Average Page Count for eBooks vs Physical Books":
          "SELECT CASE WHEN isEbook = 1 THEN 'eBooks' ELSE 'Physical Books' END AS Book_Type, AVG(pageCount) AS avg_page_count FROM books GROUP BY isEbook;",
      "8. Find the Top 3 Authors with the Most Books":
          "SELECT bookauthors, COUNT(*) AS book_count FROM books WHERE bookauthors != 'N/A' GROUP BY bookauthors ORDER BY book_count DESC LIMIT 3;",
      "9. List Publishers with More than 10 Books":
          "SELECT publisher, COUNT(*) AS book_count FROM books WHERE publisher != 'N/A' GROUP BY publisher HAVING book_count > 10;",
      "10. Find the Average Page Count for Each Category":
          "SELECT categories, AVG(pageCount) AS avg_page_count FROM books WHERE categories != 'N/A' GROUP BY categories;",
      "11. Retrieve Books with More than 3 Authors":
          """SELECT booktitle, imageLinks, bookauthors FROM books
            WHERE LENGTH(bookauthors) - LENGTH(REPLACE(bookauthors, ',', '')) >= 3;""",
      "12. Books with Ratings Count Greater Than the Average":
          """SELECT booktitle, imageLinks, ratingsCount FROM books
            WHERE ratingsCount > (SELECT AVG(ratingsCount) FROM books);""",
      "13. Books with the Same Author Published in the Same Year":
          """SELECT bookauthors, year, COUNT(*) AS book_count FROM books WHERE bookauthors != 'N/A'
            GROUP BY bookauthors, year HAVING book_count > 1;""",
      "14. Books with a Specific Keyword in the Title": "", # Placeholder for dynamic query

      "15. Year with the Highest Average Book Price":
          """SELECT year, AVG(amountretailPrice) AS avg_price FROM books
            GROUP BY year ORDER BY avg_price DESC LIMIT 1;""",
      "16. Count Authors Who Published 3 Consecutive Years":
          """SELECT bookauthors, COUNT(DISTINCT year) AS consecutive_years FROM books WHERE bookauthors != 'N/A'
            GROUP BY bookauthors HAVING consecutive_years >= 3;""",
      "17. Authors with Books Published in the Same Year by Different Publishers":
          """SELECT bookauthors, year, COUNT(DISTINCT publisher) AS publisher_count FROM books  WHERE bookauthors != 'N/A'
            GROUP BY bookauthors, year HAVING publisher_count > 1;""",
      "18. Average Retail Price of eBooks and Physical Books":
          "SELECT AVG(CASE WHEN isEbook = 1 THEN amountretailPrice ELSE NULL END) AS avg_ebook_price, AVG(CASE WHEN isEbook = 0 THEN amountretailPrice ELSE NULL END) AS avg_physical_price FROM books;",
      "19. Identify Books That Are Outliers":
          """SELECT booktitle, imageLinks, amountretailPrice FROM books
            WHERE amountretailPrice > (SELECT AVG(amountretailPrice) + 3 * STDDEV(amountretailPrice) FROM books)
            OR amountretailPrice < (SELECT AVG(amountretailPrice) - 3 * STDDEV(amountretailPrice) FROM books);""",
      "20. Publisher with the Highest Average Rating (More than 10 Books)":
          """SELECT publisher, AVG(averageRating) AS avg_rating FROM books
            GROUP BY publisher HAVING COUNT(*) > 10 ORDER BY avg_rating DESC LIMIT 1;"""
  }


  # Streamlit App
  st.title('**LET\'S ANALYZE SOME DATA**')

  # User selection
  selected_question = st.selectbox("**Select a question:**", list(queries.keys()))

  if selected_question == "14. Books with a Specific Keyword in the Title":
      keyword = st.text_input("Enter the keyword to search in book titles üî§ :")

  if st.button("üöÄRun Query"):
    with st.spinner("Fetching data..."):
      query = queries[selected_question]

      if selected_question == "14. Books with a Specific Keyword in the Title" and keyword:
          query = f"SELECT * FROM books WHERE booktitle LIKE '%{keyword}%'"
      else:
          query = queries.get(selected_question, "")

      try:
          conn = pymysql.connect(
              host=TIDB_HOST,
              port=TIDB_PORT,
              user=TIDB_USER,
              password=TIDB_PASSWORD,
              db=TIDB_DB,
              ssl={'ssl_ca': '/content/cert/ca.pem'}
          )
          # Execute the query
          data = pd.read_sql(query, conn)
          conn.close()

          if not data.empty:
              st.write(f"Results for: {selected_question}")

              # Add visualizations for each query

              if selected_question == "1. Check Availability of eBooks vs Physical Books":
                  fig = px.pie(data, names='Book_Type', values='book_count', title="eBooks vs Physical Books")
                  st.plotly_chart(fig)

              elif selected_question == "2. Find the Publisher with the Most Books Published":
                  st.metric(label="Top Publisher", value=data['publisher'][0], delta=f"{data['book_count'][0]} books")

              elif selected_question == "3. Identify the Publisher with the Highest Average Rating":
                  st.metric(label="Top Publisher", value=data['publisher'][0], delta=f"{data['avg_rating'][0]:.2f} average rating")

              elif selected_question == "15. Year with the Highest Average Book Price":
                  st.metric(label="Top Year", value=data['year'][0], delta=f"${data['avg_price'][0]:.2f} average price")

              elif selected_question == "4. Get the Top 5 Most Expensive Books by Retail Price":
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')

                    # Format the price as currency
                    data['amountretailPrice'] = data['amountretailPrice'].apply(lambda x: f"${x:,.2f}")

                    # Create an HTML table with book title, price, and book cover image
                    html_table = data[['book', 'booktitle', 'amountretailPrice']].to_html(escape=False, index=False)

                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)

              elif selected_question =="5. Find Books Published After 2010 with at Least 500 Pages":
                    # Handle missing images by providing a placeholder if the image URL is 'N/A'
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')

                    # Format the price and page count
                    data['pageCount'] = data['pageCount'].apply(lambda x: f"{x} pages")

                    # Ensure the 'year' column is treated as an integer for sorting, then format it as a string
                    data['year'] = data['year'].astype(int)  # Convert to integer to enable sorting
                    data = data.sort_values(by='year', ascending=True)  # Sort from smallest to largest year
                    data['year'] = data['year'].apply(lambda x: f"{x}")

                    # Create an HTML table with book title, page count, year, and book cover image
                    html_table = data[['book', 'booktitle', 'pageCount', 'year']].to_html(escape=False, index=False)

                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)

              elif selected_question == "6. List Books with Discounts Greater than 20%":
                    # Handle missing images by providing a placeholder if the image URL is 'N/A'
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')
                    # Format the discount_percentage column to include the '%' symbol
                    data['discount_percentage'] = data['discount_percentage'].apply(lambda x: f"{x}%")
                    # Create an HTML table with book title, page count, year, and book cover image
                    html_table = data[['book', 'booktitle', 'discount_percentage']].to_html(escape=False, index=False)

                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)


              elif selected_question == "7. Find the Average Page Count for eBooks vs Physical Books":
                  fig = px.bar(data, x='Book_Type', y='avg_page_count', title="Average Page Count (eBooks vs Physical Books)")
                  st.plotly_chart(fig)

              elif selected_question ==  "8. Find the Top 3 Authors with the Most Books":
                  fig = px.bar(data, x='bookauthors', y='book_count', title="Top 3 Authors with the Most Books", labels={'bookauthors': 'Author', 'book_count': 'Book Count'}, color='bookauthors',text='book_count')
                  st.plotly_chart(fig)


              elif selected_question == "11. Retrieve Books with More than 3 Authors":
                    # Handle missing images by providing a placeholder if the image URL is 'N/A'
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')
                    html_table = data[['book', 'booktitle', 'bookauthors']].to_html(escape=False, index=False)

                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)

              elif selected_question == "12. Books with Ratings Count Greater Than the Average":
                    # Handle missing images by providing a placeholder if the image URL is 'N/A'
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')
                    # Ensure ratingsCount is treated as an integer before sorting
                    data['ratingsCount'] = data['ratingsCount'].astype(int)

                    # Sort ratingsCount in descending order (highest ratings first)
                    data = data.sort_values(by='ratingsCount', ascending=False)

                    # Convert ratingsCount to gold stars
                    data['ratingsCount'] = data['ratingsCount'].apply(
                        lambda x: ''.join(
                            ['<span style="color: gold;">‚òÖ</span>' for _ in range(min(x, 5))]
                        )
                    )
                    html_table = data[['book', 'booktitle', 'ratingsCount']].to_html(escape=False, index=False)
                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)

              elif selected_question == "19. Identify Books That Are Outliers":
                    # Handle missing images by providing a placeholder if the image URL is 'N/A'
                    data['amountretailPrice'] = data['amountretailPrice'].apply(lambda x: f"{x:.2f}")
                    data['book'] = data['imageLinks'].apply(lambda x: f'<img src="{x}" width="100" />' if x != 'N/A' else '<img src="https://via.placeholder.com/150" width="100" />')
                    html_table = data[['book', 'booktitle', 'amountretailPrice']].to_html(escape=False, index=False)

                    # Display the HTML table with images
                    st.markdown(html_table, unsafe_allow_html=True)
              else:
                  st.dataframe(data)

          else:
              st.warning("No results found!")

      except Exception as e:
          st.error(f"Error running query: {e}")

  # Apply the background styling
  #set_light_background("#ffe6e6")  #light pink color
  set_sidebar_color(bg_color="#10A8B8", text_color="#FFFFFF")

from pyngrok import ngrok

# Terminate existing ngrok processes
ngrok.kill()

# Set your ngrok auth token
ngrok.set_auth_token("2qZXTI70wbnYK9o4Ldi7bDiVMwX_6N2MUv8REzFnRsePg6zhh")

# Start ngrok tunnel
public_url = ngrok.connect(8501)
print(f"Streamlit app is live at: {public_url}")

# Run the Streamlit app
!streamlit run book.py &>/dev/null&
